<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>24. Classical and Quantum Probability Theory &mdash; Daniel Mo Houshmand</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/togglebutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sphinx-thebe.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mo_addmination.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mo_addmination.css" type="text/css" />
    <link rel="canonical" href="https://mohoushmand.com/quantum_machine_learning/qml/1_1_QML_Quantum_Systems__Classical_And_Quantum_Probability_Theory_qiskit.html" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
        <script src="../../_static/tabs.js"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../_static/togglebutton.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script src="../../_static/design-tabs.js"></script>
        <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
        <script async="async" src="../../_static/sphinx-thebe.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="37. Measurements revisited" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html" />
    <link rel="prev" title="23.1. Quantum Machine Learning 0" href="qml_0.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/mo0.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about/about.html">About</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Art</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../art/art.html">1. Acrylic Pouring - tegneskole.no versjon</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Applied Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../applied_mathematics/applied_math.html">Computational Fluid Dynamics</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Data Science</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../data_science/stats/ds.html">Data Science</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Computer Science</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../computer_science/software_engineering/se.html">Software Engineering</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quantum Mechanics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_mechanics/quantum_mechanics.html">2. Quantum Mechanics</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quantum Computation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computation/quantum_computation.html">3. Quantum Computation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quantum Computer Hardware</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/quantum_computers.html">4. The Hardware of Quantum Computers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/quantum_computers.html#quantum-materials">5. Quantum materials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/quantum_computers.html#introduction-to-ket-notation">6. Introduction to Ket notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/quantum_computers.html#multi-qubit-states-operations">7. Multi-Qubit States &amp; Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/quantum_computers.html#advantages-and-dissadvantages-of-ket-notation">8. Advantages and dissadvantages of Ket notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/quantum_computers.html#a-fact-about-maximally-entangled-states">9. A fact about maximally entangled states</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/quantum_computers.html#experimental-and-theoretical-measurements">10. Experimental and theoretical measurements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/spin_qubits/spin_qubits.html">11. Spin Qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/superconducting_qubits/superconducting_qubits.html">12. Superconducting qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/superconducting_qubits/superconducting_qubits.html#v">13. V</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/superconducting_qubits/superconducting_qubits.html#circuit-qed">14. Circuit QED</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/superconducting_qubits/superconducting_qubits.html#assembling-a-quantum-processor">15. Assembling a quantum processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/nv_center_qubits/nv_center_qubits.html">16. NV Center Qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/quantum_annealing/quantum_annealing.html">17. Quantum Annealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/topological_qubits/topological_qubits.html">18. Topological Qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/topological_qubits/topological_qubits.html#introduction-to-topological-qubits">19. Introduction to Topological Qubits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/topological_qubits/topological_qubits.html#majorana-fermions-and-where-to-find-them">20. Majorana fermions and where to find them</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/topological_qubits/topological_qubits.html#majorana-bound-states-in-superconductors">21. Majorana bound states in superconductors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quantum_computers/topological_qubits/topological_qubits.html#majorana-experiments">22. Majorana experiments</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Quantum Machine Learning</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../quantum_machine_learning.html">23. Quantum Machine Learning Intro</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">24. Classical and Quantum Probability Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="#quantum-machine-learning-is-a-rocket-emerging">25. Quantum Machine Learning is a rocket emerging</a></li>
<li class="toctree-l1"><a class="reference internal" href="#classical-probability-distributions">26. Classical probability distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="#the-geometry-of-probability-distribution">27. The Geometry of Probability Distribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="#stochastic-matrix">28. Stochastic Matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="#quantum-states">29. Quantum states</a></li>
<li class="toctree-l1"><a class="reference internal" href="#qubits-revisited">30. Qubits revisited</a></li>
<li class="toctree-l1"><a class="reference internal" href="#superposition-revisited">31. Superposition revisited</a></li>
<li class="toctree-l1"><a class="reference internal" href="#bloch-sphere-revisited">32. Bloch Sphere revisited</a></li>
<li class="toctree-l1"><a class="reference internal" href="#interference">33. Interference</a></li>
<li class="toctree-l1"><a class="reference internal" href="#more-qubits-and-entanglement">34. More qubits and entanglement</a></li>
<li class="toctree-l1"><a class="reference internal" href="#multiple-qubits-revisited">35. Multiple Qubits revisited</a></li>
<li class="toctree-l1"><a class="reference internal" href="#further-reading">36. Further reading</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html">37. Measurements revisited</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#bra-ket-notation">38. Bra-Ket Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#dot-product">39. Dot product</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#ket-bra">40. Ket-Bra</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#more-on-the-bra-ket-notation">41. More on the bra-ket notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#more-on-measurements">42. More on Measurements</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#collapse-of-the-wave-function">43. Collapse of the Wave Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#the-born-rule">44. The Born Rule</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#measuring-multiqubit-systems">45. Measuring multiqubit systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#mixed-states">46. Mixed States</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html#density-matrix">47. Density Matrix</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_3_QML_Quantum_Systems__Evolution_in_Closed_and_Open_Systems_qiskit_QDaria.html">48. Evolution in Closed Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_3_QML_Quantum_Systems__Evolution_in_Closed_and_Open_Systems_qiskit_QDaria.html#unitary-evolution">49. Unitary evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_3_QML_Quantum_Systems__Evolution_in_Closed_and_Open_Systems_qiskit_QDaria.html#more-on-the-unitary-evolution">50. More on the Unitary evolution</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_3_QML_Quantum_Systems__Evolution_in_Closed_and_Open_Systems_qiskit_QDaria.html#open-quantum-systems">51. Open Quantum Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_3_QML_Quantum_Systems__Evolution_in_Closed_and_Open_Systems_qiskit_QDaria.html#interaction-with-the-environment-open-systems">52. Interaction with the environment: open systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_4_QML_Quantum_Systems__Classical_and_Quantum_Many_Body_Physics_qiskitQDaria.html">53. Classical Ising Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_4_QML_Quantum_Systems__Classical_and_Quantum_Many_Body_Physics_qiskitQDaria.html#hamiltonian">54. Hamiltonian</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_4_QML_Quantum_Systems__Classical_and_Quantum_Many_Body_Physics_qiskitQDaria.html#the-ising-model">55. The Ising model</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_4_QML_Quantum_Systems__Classical_and_Quantum_Many_Body_Physics_qiskitQDaria.html#the-transverse-field-ising-model">56. The transverse-field Ising model</a></li>
<li class="toctree-l1"><a class="reference internal" href="1_4_QML_Quantum_Systems__Classical_and_Quantum_Many_Body_Physics_qiskitQDaria.html#commuting-hamiltonian">57. Commuting Hamiltonian</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_1_QML_Quantum_Computations_%2805%29__Gate_Model_Quantum_Computing_qiskitQDaria.html">58. Gate-Model Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_1_QML_Quantum_Computations_%2805%29__Gate_Model_Quantum_Computing_qiskitQDaria.html#quantum-approximate-optimization-algorithm">59. Quantum Approximate Optimization Algorithm.</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_1_QML_Quantum_Computations_%2805%29__Gate_Model_Quantum_Computing_qiskitQDaria.html#solovay-kitaev-theorem">60. Solovay-Kitaev theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_1_QML_Quantum_Computations_%2805%29__Gate_Model_Quantum_Computing_qiskitQDaria.html#quantum-circuits">61. Quantum Circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_1_QML_Quantum_Computations_%2805%29__Gate_Model_Quantum_Computing_qiskitQDaria.html#hadamard-gate">62. Hadamard gate</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_1_QML_Quantum_Computations_%2805%29__Gate_Model_Quantum_Computing_qiskitQDaria.html#the-cnot-gate">63. The CNOT gate</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_1_QML_Quantum_Computations_%2805%29__Gate_Model_Quantum_Computing_qiskitQDaria.html#defining-circuits">64. Defining circuits</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_1_QML_Quantum_Computations_%2805%29__Gate_Model_Quantum_Computing_qiskitQDaria.html#compilation">65. Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_1_QML_Quantum_Computations_%2805%29__Gate_Model_Quantum_Computing_qiskitQDaria.html#references">66. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html">67. Adiabatic Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#adiabatic-theorem">68. Adiabatic Theorem</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#unitary-evolution-and-the-hamiltonian">69. Unitary evolution and the Hamiltonian</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#the-adiabatic-theorem-and-adiabatic-quantum-computing">70. The adiabatic theorem and adiabatic quantum computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#quantum-annealing">71. Quantum Annealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#chimera-graph">72. Chimera Graph</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#id1">73. Quantum annealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#references">74. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#implementations">75. Implementations</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#superconducting-architectures">76. Superconducting Architectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#dissadvantages">77. Dissadvantages</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#trapped-ions">78. Trapped ions</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_2_QML_2_Quantum_Computation%2806%29__Adiabatic_Quantum_Computing_qiskit.html#photonic-systems">79. Photonic Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_3_QML_Quantum_Computation%2807%29__Variational_Circuits_qiskit.html">80. Quantum Approximate Optimization Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_3_QML_Quantum_Computation%2807%29__Variational_Circuits_qiskit.html#id1">81. Quantum approximate optimization algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_3_QML_Quantum_Computation%2807%29__Variational_Circuits_qiskit.html#analysis-of-the-results">82. Analysis of the results</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_1_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%289%29__Discrete_Optimization_And_Ensemble_Learning_qiskit%28Ecoding_Classical_Inforfmation%29.html">83. Encoding Classical Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_1_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%289%29__Discrete_Optimization_And_Ensemble_Learning_qiskit%28Ecoding_Classical_Inforfmation%29.html#loss-functions-and-regularization">84. Loss Functions and Regularization</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_1_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%289%29__Discrete_Optimization_And_Ensemble_Learning_qiskit%28Ecoding_Classical_Inforfmation%29.html#ensemble-learning">85. Ensemble Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_1_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%289%29__Discrete_Optimization_And_Ensemble_Learning_qiskit%28Ecoding_Classical_Inforfmation%29.html#ensemble-methods">86. Ensemble methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_1_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%289%29__Discrete_Optimization_And_Ensemble_Learning_qiskit%28Ecoding_Classical_Inforfmation%29.html#qboost">87. Qboost</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_1_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%289%29__Discrete_Optimization_And_Ensemble_Learning_qiskit%28Ecoding_Classical_Inforfmation%29.html#more-qboost">88. More QBoost</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_1_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%289%29__Discrete_Optimization_And_Ensemble_Learning_qiskit%28Ecoding_Classical_Inforfmation%29.html#solving-by-qaoa">89. Solving by QAOA</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_1_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%289%29__Discrete_Optimization_And_Ensemble_Learning_qiskit%28Ecoding_Classical_Inforfmation%29.html#references">90. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_2_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2810%29__Discrete_Optimization_and_Unsupervised_Learning_qiskit.html">91. Clustering by Quantum Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_2_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2810%29__Discrete_Optimization_and_Unsupervised_Learning_qiskit.html#mapping-clustering-to-discrete-optimization">92. Mapping clustering to discrete optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_2_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2810%29__Discrete_Optimization_and_Unsupervised_Learning_qiskit.html#solving-the-max-cut-problem-by-qaoa">93. Solving the max-cut problem by QAOA</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_2_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2810%29__Discrete_Optimization_and_Unsupervised_Learning_qiskit.html#solving-the-max-cut-problem-by-annealing">94. Solving the max-cut problem by annealing</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_2_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2810%29__Discrete_Optimization_and_Unsupervised_Learning_qiskit.html#references">95. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_3_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2811%29__Kernel_Methods_qiskit.html">96. Kernel Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_3_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2811%29__Kernel_Methods_qiskit.html#an-inference">97. An Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_3_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2811%29__Kernel_Methods_qiskit.html#thinking-backward-learning-methods-based-on-what-the-hardware-can-do">98. Thinking backward: learning methods based on what the hardware can do</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_3_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2811%29__Kernel_Methods_qiskit.html#a-natural-kernel-on-a-shallow-circuit">99. A natural kernel on a shallow circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_3_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2811%29__Kernel_Methods_qiskit.html#references">100. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html">101. An Inference Circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#tror-ikke-skal-vaere-her-men-i-11">102. (Tror ikke skal være her men i (11))</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#probalistic-graphical-model">103. Probalistic Graphical Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#gfx">104. GFX!!!??</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#probabilistic-graphical-models">105. Probabilistic graphical models</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#optimization-and-sampling-pgms">106. Optimization and Sampling PGMs</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#se-igjen-i-lyx-husk-implementering-og-plots">107. Se igjen i lyx (Husk implementering og plots)</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#se-bildet-grafen-pa-lyx">108. Se bildet grafen på lyx</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#boltzmann-machines">109. Boltzmann machines</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#references">110. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_4_QML_Classical_Quantum_Hybrid_Learning_Algorithms_%2812%29__Training_Probabilistic_Graphical_Models.html#se-eksamen">111. SE EKSAMEN!!!</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_1_QML_Coherent_Learning_Protocols_%2813%29__Quantum_Phase_Estimation_qiskit.html">112. Quantum Fourier Transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_1_QML_Coherent_Learning_Protocols_%2813%29__Quantum_Phase_Estimation_qiskit.html#introduction">113. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_1_QML_Coherent_Learning_Protocols_%2813%29__Quantum_Phase_Estimation_qiskit.html#id1">114. Quantum Fourier Transform</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_1_QML_Coherent_Learning_Protocols_%2813%29__Quantum_Phase_Estimation_qiskit.html#even-more-quantum-phase-estimation">115. Even more Quantum Phase Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_1_QML_Coherent_Learning_Protocols_%2813%29__Quantum_Phase_Estimation_qiskit.html#quantum-phase-estimation">116. Quantum phase estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_1_QML_Coherent_Learning_Protocols_%2813%29__Quantum_Phase_Estimation_qiskit.html#references">117. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html">118. Overview of the Harrow-Hassidim-Lloyd Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#introduction">119. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#setting-up-the-problem">120. Setting up the problem</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#quantum-matrix-inversion">121. Quantum Matrix Inversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#quantum-phase-estimation">122. Quantum phase estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#using-quantum-linear-algebra-for-learning">123. Using Quantum Linear Algebra for Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#conditional-rotation-of-ancilla">124. Conditional rotation of ancilla</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#uncomputing-the-eigenvalue-register">125. Uncomputing the eigenvalue register</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#rejection-sampling-on-the-ancilla-register-and-a-swap-test">126. Rejection sampling on the ancilla register and a swap test</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#quantum-assisted-gaussian-processes">127. Quantum-Assisted Gaussian Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_2_QML_Coherent_Learning_%2814%29__Quantum_Matrix_Inversion_qiskit.html#references">128. References</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_1_QML_Lecture_%2815%29__quantumkernels_svm.html">129. Integrating quantum kernels into scikit-learn</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_1_QML_Lecture_%2815%29__quantumkernels_svm.html#preliminaries">130. Preliminaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_1_QML_Lecture_%2815%29__quantumkernels_svm.html#data-preparation">131. Data preparation</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_1_QML_Lecture_%2815%29__quantumkernels_svm.html#training">132. Training</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_2_QML_Lecture_%2816%29__quantumkernels_variational.html">133. Creating a variational classifier with PennyLane</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_2_QML_Lecture_%2816%29__quantumkernels_variational.html#the-variational-circuit">134. The variational circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_2_QML_Lecture_%2816%29__quantumkernels_variational.html#importing-libraries">135. Importing libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_2_QML_Lecture_%2816%29__quantumkernels_variational.html#implementing-the-circuit">136. Implementing the circuit</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_2_QML_Lecture_%2816%29__quantumkernels_variational.html#loading-data">137. Loading data</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_2_QML_Lecture_%2816%29__quantumkernels_variational.html#visualising-the-decision-boundary">138. Visualising the decision boundary</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_2_QML_Lecture_%2816%29__quantumkernels_variational.html#more-training">139. More Training</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Ruter</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../ruter/ruter.html">Ruter</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">24. </span>Classical and Quantum Probability Theory</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/quantum_machine_learning/qml/1_1_QML_Quantum_Systems__Classical_And_Quantum_Probability_Theory_qiskit.ipynb" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="classical-and-quantum-probability-theory">
<h1><span class="section-number">24. </span>Classical and Quantum Probability Theory<a class="headerlink" href="#classical-and-quantum-probability-theory" title="Permalink to this headline"></a></h1>
<section id="what-are-the-elements-of-a-quantum-circuit">
<h2><span class="section-number">24.1. </span>What are the elements of a quantum circuit?<a class="headerlink" href="#what-are-the-elements-of-a-quantum-circuit" title="Permalink to this headline"></a></h2>
<p>Every computation has three elements: Data, operations and result</p>
<p>In quantum circuits:</p>
<ul class="simple">
<li><p>Data = Qubits</p></li>
<li><p>Operations = Quantum Gates (Unitary Transformation)</p></li>
<li><p>Result = Measurements</p></li>
</ul>
</section>
<section id="about-qutip">
<h2><span class="section-number">24.2. </span>About QuTiP<a class="headerlink" href="#about-qutip" title="Permalink to this headline"></a></h2>
<p>Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. <br></p>
<p>In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.</p>
<p>While a classical bit which is binary can thought of as a an unbiased coinflip Heads <span class="math notranslate nohighlight">\((H)\)</span> or Tails <span class="math notranslate nohighlight">\((T)\)</span> with
$<span class="math notranslate nohighlight">\(P(H)=P(T)=0.5\)</span>$
A quantum bit on the other hand, or more famously a qubit, could be visualised as a spinning coin that hasn’t decided yet. While it’s spinning, from the naked eyes it looks like a sphere</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="quantum-machine-learning-is-a-rocket-emerging">
<h1><span class="section-number">25. </span>Quantum Machine Learning is a rocket emerging<a class="headerlink" href="#quantum-machine-learning-is-a-rocket-emerging" title="Permalink to this headline"></a></h1>
<p>While Machine learning is how classical computers learn patterns in data. Quantum machine learning on the other hand is about how Quantum Computers and other quantum information processors can learn patterns in data that is impossible for classical machine learning algorithms to learne.</p>
<p>The notions and properties of calssical probability distributions can be distinguished from Quantum states. can be thought of as  with certain properties that can be distinguished from our classical notion of probabilities. By contrasting these two properties, we can straightforwardly and easily formulate some of the most basic concepts needed in quantum computing.</p>
<p>Alongside probability theory, linear algebra is also crucially important for many learning protocols. In quantum computing is in general all about linear algebra. We will demonstrate how intrinsically linked quantum computing, geometry and probabilities are. Geometric notions are also familiarity in dealing with classical probability distributions. This notebook first talks about classical probabilities and stochastic vectors, and introduces quantum states as a natural generalization.</p>
<p>Throughout this course, we will assume finite probability distributions and finite dimensional spaces. This significantly simplifies notation and most quantum computers operate over finite dimensional spacese, so we do not lose much in generality.</p>
<p>Throughout the following chapters we will assume finite probability distributions and finite dimensional spaces. This significantly simplifies notation and most quantum computers operate over finite dimensional spaces, so we do not lose much in generality.</p>
<p>We’ve introduced quantum states as a generalization of classical probability distributions and quantum computations as a way of transforming these probability distributions. Before we get to quantum states and quantum computations, let’s look at a couple of elements of classical probability theory. So let’s start by looking at coin flipping. so coin flipping has two possible outcomes– heads or tails. And we associate the probability with each of these outcomes some P0 probability with heads and P1 with tails.</p>
<p>Classical probability distributions can be thought of as a special case of the more generalized quantum states, and quantum computation is the way of transforming these probability distributions. Before diving into quantum states and quantum computations, let’s exploit some classical probability theory elements. A coin flip is an instructive starting point where we have two possible outcomes - heads or tails, associated with equally probable outcomes where p0 is the probability for heads and p1 for tails. More formally the probability for the outcome X to be H which is head is p0, and the same for tails T</p>
<p>Probability theory is a cornerstone for machine learning. We can think of quantum states as probability distributions with certain properties that make them different from our classical notion of probabilities. Contrasting these properties is an easy and straightforward introduction to the most basic concepts we need in quantum computing.</p>
<p>Apart from probability theory, linear algebra is also critical for many learning protocols. As we will see, geometry and probabilities are intrinsically linked in quantum computing, but geometric notions are also familiar in dealing with classical probability distributions. This notebook first talks about classical probabilities and stochastic vectors, and introduces quantum states as a natural generalization.</p>
<p>Throughout this course, we will assume finite probability distributions and finite dimensional spaces. This significantly simplifies notation and most quantum computers operate over finite dimensional spaces, so we do not lose much in generality.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="classical-probability-distributions">
<h1><span class="section-number">26. </span>Classical probability distributions<a class="headerlink" href="#classical-probability-distributions" title="Permalink to this headline"></a></h1>
<p>Let us toss a biased coin. Without getting too technical, we can associate a random variable <span class="math notranslate nohighlight">\(X\)</span> with the output: it takes the value 0 for heads and the value 1 for tails. We get heads with probability <span class="math notranslate nohighlight">\(P(X=0) = p_0\)</span> and tails with <span class="math notranslate nohighlight">\(P(X=1) = p_1\)</span> for each toss of the coin. In classical, Kolmogorovian probability theory, <span class="math notranslate nohighlight">\(p_i\geq 0\)</span> for all <span class="math notranslate nohighlight">\(i\)</span>, and the probabilities sum to one: <span class="math notranslate nohighlight">\(\sum_i p_i = 1\)</span>. Let’s sample this distribution</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">p_1</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">x_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p_1</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0
 0 1 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1 1 0 1 0 0 1 0 0 1 0 1
 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 0 0]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>numpy.ndarray
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x_data</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>23
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;H&#39;</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="k">else</span> <span class="s1">&#39;T&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">flips</span> <span class="o">=</span> <span class="p">[</span><span class="n">flip</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="nb">float</span><span class="p">(</span><span class="n">flips</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">))</span><span class="o">/</span><span class="n">N</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.58
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">flips</span> <span class="o">=</span> <span class="p">[</span><span class="n">flip</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">150</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="nb">float</span><span class="p">(</span><span class="n">flips</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">))</span><span class="o">/</span><span class="n">N</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.5
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">flips</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>100
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">flips</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;H&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">string</span><span class="p">):</span> 
    <span class="k">return</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span>
    <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span>
    <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="s1">&#39;5&#39;</span><span class="p">,</span>
    <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="s1">&#39;6&#39;</span><span class="p">,</span>
    <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="s1">&#39;7&#39;</span><span class="p">,</span>
    <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="s1">&#39;8&#39;</span><span class="p">,</span>
    <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="s1">&#39;9&#39;</span><span class="p">,</span>
    <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="s1">&#39;10&#39;</span><span class="p">,</span>
    <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="s1">&#39;11&#39;</span><span class="p">,</span>
    <span class="s1">&#39;l&#39;</span><span class="p">:</span> <span class="s1">&#39;12&#39;</span><span class="p">,</span>
    <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="s1">&#39;13&#39;</span><span class="p">,</span>
    <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;14&#39;</span><span class="p">,</span>
    <span class="s1">&#39;o&#39;</span><span class="p">:</span> <span class="s1">&#39;15&#39;</span><span class="p">,</span>
    <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="s1">&#39;16&#39;</span><span class="p">,</span>
    <span class="s1">&#39;q&#39;</span><span class="p">:</span> <span class="s1">&#39;17&#39;</span><span class="p">,</span>
    <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;18&#39;</span><span class="p">,</span>
    <span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="s1">&#39;19&#39;</span><span class="p">,</span>
    <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="s1">&#39;20&#39;</span><span class="p">,</span>
    <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="s1">&#39;21&#39;</span><span class="p">,</span>
    <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="s1">&#39;22&#39;</span><span class="p">,</span>
    <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="s1">&#39;23&#39;</span><span class="p">,</span>
    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;24&#39;</span><span class="p">,</span>
    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;25&#39;</span><span class="p">,</span>
    <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;26&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">word</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">))</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">StdinNotImplementedError</span><span class="g g-Whitespace">                  </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">line</span> <span class="mi">32</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span>     <span class="k">return</span> <span class="n">string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> 
<span class="g g-Whitespace">      </span><span class="mi">5</span>     <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;2&#39;</span><span class="p">,</span>
<span class="g g-Whitespace">      </span><span class="mi">6</span>     <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;3&#39;</span><span class="p">,</span>
   <span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">29</span>     <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;26&#39;</span><span class="p">,</span>
<span class="g g-Whitespace">     </span><span class="mi">30</span> <span class="p">}</span>
<span class="ne">---&gt; </span><span class="mi">32</span> <span class="n">word</span> <span class="o">=</span> <span class="n">remove</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">))</span>
<span class="g g-Whitespace">     </span><span class="mi">34</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">35</span>     <span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>

<span class="nn">File ~/micromamba/envs/mom1env/lib/python3.8/site-packages/ipykernel/kernelbase.py:1190,</span> in <span class="ni">Kernel.raw_input</span><span class="nt">(self, prompt)</span>
<span class="g g-Whitespace">   </span><span class="mi">1188</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_allow_stdin</span><span class="p">:</span>
<span class="g g-Whitespace">   </span><span class="mi">1189</span>     <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;raw_input was called, but this frontend does not support input requests.&quot;</span>
<span class="ne">-&gt; </span><span class="mi">1190</span>     <span class="k">raise</span> <span class="n">StdinNotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
<span class="g g-Whitespace">   </span><span class="mi">1191</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_input_request</span><span class="p">(</span>
<span class="g g-Whitespace">   </span><span class="mi">1192</span>     <span class="nb">str</span><span class="p">(</span><span class="n">prompt</span><span class="p">),</span>
<span class="g g-Whitespace">   </span><span class="mi">1193</span>     <span class="bp">self</span><span class="o">.</span><span class="n">_parent_ident</span><span class="p">[</span><span class="s2">&quot;shell&quot;</span><span class="p">],</span>
<span class="g g-Whitespace">   </span><span class="mi">1194</span>     <span class="bp">self</span><span class="o">.</span><span class="n">get_parent</span><span class="p">(</span><span class="s2">&quot;shell&quot;</span><span class="p">),</span>
<span class="g g-Whitespace">   </span><span class="mi">1195</span>     <span class="n">password</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="g g-Whitespace">   </span><span class="mi">1196</span> <span class="p">)</span>

<span class="ne">StdinNotImplementedError</span>: raw_input was called, but this frontend does not support input requests.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
   <span class="nb">print</span><span class="p">(</span><span class="nb">dict</span><span class="p">[</span><span class="n">word</span><span class="p">[</span><span class="n">index</span><span class="p">]])</span>
   <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>23
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># for inline plots in jupyter</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="c1"># import matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># for latex equations</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">Math</span><span class="p">,</span> <span class="n">Latex</span>
<span class="c1"># for displaying images</span>
<span class="kn">from</span> <span class="nn">IPython.core.display</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="c1"># import seaborn</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="c1"># settings for seaborn plotting style</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">color_codes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># settings for seaborn plot sizes</span>
<span class="n">sns</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">rc</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;figure.figsize&#39;</span><span class="p">:(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)})</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="c1"># generate random numbers from N(0,1)</span>
<span class="n">data_normal</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">distplot</span><span class="p">(</span><span class="n">data_normal</span><span class="p">,</span>
                  <span class="n">bins</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                  <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">color</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span>
                  <span class="n">hist_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;linewidth&quot;</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Normal Distribution&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/seaborn/distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
  warnings.warn(msg, FutureWarning)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Text(0.5, 0, &#39;Normal Distribution&#39;), Text(0, 0.5, &#39;Frequency&#39;)]
</pre></div>
</div>
<img alt="../../_images/ca6dc1bc47cbd8ade4577ec615f1042acef3fc36f28bad4ef4a0e3d4208254db.png" src="../../_images/ca6dc1bc47cbd8ade4577ec615f1042acef3fc36f28bad4ef4a0e3d4208254db.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#[Text(0,0.5,u&#39;Frequency&#39;), Text(0.5,0,u&#39;Normal Distribution&#39;)]</span>
</pre></div>
</div>
</div>
</div>
<p>https://www.kaggle.com/nowke9/statistics-2-distributions</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">bernoulli</span>
<span class="n">data_bern</span> <span class="o">=</span> <span class="n">bernoulli</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span><span class="o">=</span> <span class="n">sns</span><span class="o">.</span><span class="n">distplot</span><span class="p">(</span><span class="n">data_bern</span><span class="p">,</span>
                 <span class="n">kde</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="c1">#False</span>
                 <span class="n">color</span><span class="o">=</span><span class="s2">&quot;skyblue&quot;</span><span class="p">,</span>
                 <span class="n">hist_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;linewidth&quot;</span><span class="p">:</span> <span class="mi">19</span><span class="p">,</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;Bernoulli Distribution&#39;</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/seaborn/distributions.py:2619: FutureWarning: `distplot` is a deprecated function and will be removed in a future version. Please adapt your code to use either `displot` (a figure-level function with similar flexibility) or `histplot` (an axes-level function for histograms).
  warnings.warn(msg, FutureWarning)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Text(0.5, 0, &#39;Bernoulli Distribution&#39;), Text(0, 0.5, &#39;Frequency&#39;)]
</pre></div>
</div>
<img alt="../../_images/2e1fdc2dd5d443b425ab5465e5744b332cf3db0dac0a01903b11beb30a71b7b1.png" src="../../_images/2e1fdc2dd5d443b425ab5465e5744b332cf3db0dac0a01903b11beb30a71b7b1.png" />
</div>
</div>
<p>https://www.datacamp.com/community/tutorials/probability-distributions-python</p>
<p><strong>End Test</strong></p>
<p>We naturally expect that the empirically observed frequencies also sum to one:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">frequency_of_zeros</span><span class="p">,</span> <span class="n">frequency_of_ones</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_data</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">frequency_of_ones</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n_samples</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">frequency_of_zeros</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">/</span><span class="n">n_samples</span>
<span class="nb">print</span><span class="p">(</span><span class="n">frequency_of_ones</span><span class="o">+</span><span class="n">frequency_of_zeros</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0000000000000004
</pre></div>
</div>
</div>
</div>
<p>Since <span class="math notranslate nohighlight">\(p_0\)</span> and <span class="math notranslate nohighlight">\(p_1\)</span> must be non-negative, all possible probability distributions are restricted to the positive orthant. The normalization constraint puts every possible distribution on a straight line. This plot describes all possible probability distributions by biased and unbiased coins.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="n">p_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">p_1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">p_0</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;$p_0$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_label_coords</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$p_1$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_coords</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p_0</span><span class="p">,</span> <span class="n">p_1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x287e01c90&gt;]
</pre></div>
</div>
<img alt="../../_images/4017629a3f3aca2381b4da6387b9d6f6b8ee38174fd7df21692d7595e6c394f9.png" src="../../_images/4017629a3f3aca2381b4da6387b9d6f6b8ee38174fd7df21692d7595e6c394f9.png" />
</div>
</div>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="the-geometry-of-probability-distribution">
<h1><span class="section-number">27. </span>The Geometry of Probability Distribution<a class="headerlink" href="#the-geometry-of-probability-distribution" title="Permalink to this headline"></a></h1>
<p>Now, let’s take a look at the bit of the geometry of that probability distribution. So if you have a probability distribution like this, you can also write it as a vector.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{p}=\left[\begin{array}{c}
p_{0}\\
p_{1}
\end{array}\right]\end{split}\]</div>
<p>stochastic vector.</p>
<p>If we just take these probability values into a column vector, and we put a little arrow on top of the P to reflect that it’s a vector. We are going to do something very, very similar in quantum states. Quantum states are also normally represented by a column vector, and they have a particular notation to reflect that it’s a column vector. Now, the entries are all non-negative real values. And we also know that they are summed to 1.</p>
<p>But this summation is actually the same as the summation of the absolute value, since we talk about non-negative numbers. Which means that we normalize the P vector in the 1 norm. So this is going to be normalized to 1 in the 1 norm.</p>
<div class="math notranslate nohighlight">
\[\sum_{i}p_{i}=\sum_{i}\mid p_{i}\mid=\mid\boldsymbol{p}\mid_{1}\]</div>
<p>This is, again, very important, because in quantum states the normalization is going to be in a different norm.</p>
<p><strong>finish</strong></p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="stochastic-matrix">
<h1><span class="section-number">28. </span>Stochastic Matrix<a class="headerlink" href="#stochastic-matrix" title="Permalink to this headline"></a></h1>
<p>Lastly, let’s take a look at how we transform probability distributions. So now we can take this stochastic vector, and we want to end up with another stochastic vector– another probability distribution. To ensure this, the transformation that we apply on this vector must fulfill certain requirements.</p>
<div class="math notranslate nohighlight">
\[M\boldsymbol{p}=\boldsymbol{p}'\]</div>
<p>M is left stochastic matrix. $<span class="math notranslate nohighlight">\(p_{i}'\geq0\)</span>$</p>
<div class="math notranslate nohighlight">
\[\mid\mid\boldsymbol{p}\mid\mid_{1}=1\]</div>
<p>In the case of a left stochastic matrix, which means that we apply from the left of the stochastic vector, this means that the columns must add up to 1. Quantum calculations will also be some kind of matrix operations which will fulfill certain mathematical properties. They are going to be unitary operations, and they will transform quantum states or quantum probabilities into other quantum states.</p>
<section id="quiz-classical-probability-distribution">
<h2><span class="section-number">28.1. </span>Quiz Classical Probability Distribution<a class="headerlink" href="#quiz-classical-probability-distribution" title="Permalink to this headline"></a></h2>
<p><strong>All classical probability distributions of coin flipping lie on…</strong></p>
<p>– The unit circle in the <span class="math notranslate nohighlight">\(l_{1}\)</span> norm restricted to the positive orthant.</p>
<p><strong>You are given a biased 6-sided dice where side 1 has a higher probability than all the other sides. The entropy is…</strong></p>
<p>– lower than <span class="math notranslate nohighlight">\(\log_{2}6\)</span>.</p>
<p><strong>A stochastic matrix</strong></p>
<p>– Transforms a stochastic vector to another stochastic vector.
<em>Finish</em></p>
<p>We may also arrange the probabilities in a vector</p>
<div class="math notranslate nohighlight">
\[\begin{split}\vec{p} = \begin{bmatrix} p_0 \\ p_1 \end{bmatrix}\end{split}\]</div>
<p>Here, for notational convenience, we put an arrow above the variable representing the vector, to distinguish it from scalars. You will see that quantum states also have a standard notation that provides convenience, but goes much further in usefulness than the humble arrow here.</p>
<p>A vector representing a probability distribution is called a <em>stochastic vector</em>. The normalization constraint essentially says that the norm of the vector is restricted to one in the <span class="math notranslate nohighlight">\(l_1\)</span> norm. In other words,
$<span class="math notranslate nohighlight">\(\mid \mid \vec{p}\mid \mid_{1} = \sum_i |p_i| = 1\)</span><span class="math notranslate nohighlight">\(. 
This would be the unit circle in the \)</span>l_1<span class="math notranslate nohighlight">\( norm, but since \)</span>p_i\geq 0$, we are restricted to a quarter of the unit circle, just as we plotted above. We can easily verify this with numpy’s norm function:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.8</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.0
</pre></div>
</div>
</div>
</div>
<p>We know that the probability of heads is just the first element in the <span class="math notranslate nohighlight">\(\vec{p}\)</span>, but since it is a vector, we could use linear algebra to extract it. Geometrically, it means that we project the vector to the first axis. This projection is described by the matrix
$<span class="math notranslate nohighlight">\(\begin{bmatrix} 1 &amp; 0\\0 &amp; 0\end{bmatrix}\)</span><span class="math notranslate nohighlight">\( 
The length in the \)</span>l_1$ norm gives the sought probability:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Π_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Π_0</span> <span class="o">@</span> <span class="n">p</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.8
</pre></div>
</div>
</div>
</div>
<p>We can repeat the process to get the probability of tails:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Π_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Π_1</span> <span class="o">@</span> <span class="n">p</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.2
</pre></div>
</div>
</div>
</div>
<p>The two projections play an equivalent role to the values 0 and 1 when we defined the probability distribution. In fact, we could define a new random variable called <span class="math notranslate nohighlight">\(\Pi\)</span> that can take the projections <span class="math notranslate nohighlight">\(\Pi_0\)</span> and <span class="math notranslate nohighlight">\(\Pi_1\)</span> as values and we would end up with an identical probability distribution. This may sound convoluted and unnatural, but the measurement in quantum mechanics is essentially a random variable that takes operator values, such as projections.</p>
<p>What happens when we want to transform a probability distribution to another one? For instance, to change the bias of a coin, or to describe the transition of a Markov chain. Since the probability distribution is also a stochastic vector, we can apply a matrix on the vector, where the matrix has to fulfill certain conditions. A left <em>stochastic matrix</em> will map stochastic vectors to stochastic vectors when multiplied from the left: its columns add up to one. In other words, it maps probability distributions to probability distributions. For example, starting with a unbiased coin, the map <span class="math notranslate nohighlight">\(M\)</span> will transform the distribution to a biased coin:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">.5</span><span class="p">]])</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">M</span> <span class="o">@</span> <span class="n">p</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.9999999999999999
</pre></div>
</div>
</div>
</div>
<p>One last concept that will come handy is entropy. A probability distribution’s entropy is defined as
$<span class="math notranslate nohighlight">\(H(p) = - \sum_i p_i \log_2 p_i\)</span>$</p>
<p>And the plot over all possible probability distributions of coin tosses:</p>
</section>
<section id="entropy">
<h2><span class="section-number">28.2. </span>Entropy<a class="headerlink" href="#entropy" title="Permalink to this headline"></a></h2>
<p>Now let’s pay attention to another concept called <strong>entropy</strong>. Entropy is a characterization of a probability distribution, and tells something about its unpredictability. It peaks at the unbiased coin, which is the uniform distribution and we’ll get all outcomes with the same probability. This is the most unpredictable case where in this case, we flip the coin, we have absolutely no predictive power of what the next coin flip is going to give us. Whereas if the coin is biased either way, it has a lower complexity and it becomes easier to make probabilistic predictions about the future outcome.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ϵ</span> <span class="o">=</span> <span class="mf">10e-10</span>
<span class="n">p_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ϵ</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">ϵ</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">p_1</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">p_0</span>
<span class="n">H</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">p_0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p_0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p_1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">p_1</span><span class="p">))</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;$p_0$&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$H$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p_0</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.lines.Line2D at 0x287de3e20&gt;
</pre></div>
</div>
<img alt="../../_images/c1cd51a214bf61909431df7117b1b2cb1b259fb6c542398c261a34b51f4c1e2c.png" src="../../_images/c1cd51a214bf61909431df7117b1b2cb1b259fb6c542398c261a34b51f4c1e2c.png" />
</div>
</div>
<p>Here we can see that the entropy is maximal for the unbiased coin. This is true in general: the entropy peaks for the uniform distribution. In a sense, this is the most unpredictable distribution: if we get heads with probability 0.2, betting tails is a great idea. On the other hand, if the coin is unbiased, then a deterministic strategy is of little help in winning. Entropy quantifies this notion of surprise and unpredictability.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="quantum-states">
<h1><span class="section-number">29. </span>Quantum states<a class="headerlink" href="#quantum-states" title="Permalink to this headline"></a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="qubits-revisited">
<h1><span class="section-number">30. </span>Qubits revisited<a class="headerlink" href="#qubits-revisited" title="Permalink to this headline"></a></h1>
<p>In the previous we introduced classical probability theories and the stochastic vector, which describes a probability distribution. So, based on that, we can easily introduce quantum states. So a quantum state is just like stochastic vector. You can write it as a column vector.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]\qquad}a\in\mathbb{C}\end{split}\]</div>
<p>But the big difference is that you are not restricted to real numbers and nonnegative real numbers, because the entries in this vector are complex values. And the normalization of this vector doesn’t happen in the one norm, it happens in the two norm.</p>
<div class="math notranslate nohighlight">
\[\Vert\mid\psi\rangle\Vert_{2}=1\]</div>
<p>So it’s still normalizing to <span class="math notranslate nohighlight">\(1\)</span>, but now the square sum of the absolute values of the entries is what adds up to 1, as opposed to just the absolute values adding up to <span class="math notranslate nohighlight">\(1\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]\qquad}a\in\mathbb{C}\end{split}\]</div>
<p>This is the simplest possible quantum state. It has two possible outcomes. This is often referred to as a qubit.</p>
<p><strong>Finish</strong></p>
<p>A classical coin is a two-level system: it is either heads or tails. At a first look a quantum state is a probability distribution, and the simplest case is a two-level state, which we call a qubit. Just like the way we can write the probability distribution as a column vector, we can write a quantum state as a column vector. For notational convenience that will become apparent later, we write the label of a quantum state in what is called a ket in the Dirac notation. So for instance, for some qubit, we can write</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid \psi\rangle = \begin{bmatrix}a_0 \\ a_1 \\\end{bmatrix}\end{split}\]</div>
<p>In other words, a ket is just a column vector, exactly like the stochastic vector in the classical case. Instead of putting an arrow over the name of the variable to express that it is a vector, we use the ket to say that it is a column vector that represents a quantum state. There’s more to this notation, as we will see.</p>
<p>The key difference to classical probability distributions and stochastic vectors is the normalization constraint. The square sum of their absolute values adds up to 1:</p>
<div class="math notranslate nohighlight">
\[\sqrt{|a_0|^2+|a_1|^2}=1\]</div>
<p>where
$<span class="math notranslate nohighlight">\(a_0, a_1\in \mathbb{C}\)</span>$</p>
<p>In other words, we are normalizing in the <span class="math notranslate nohighlight">\(l_2\)</span> norm instead of the <span class="math notranslate nohighlight">\(l_1\)</span> norm. Furthermore, we are no longer restricted to the positive orthant: the components of the quantum state vector, which we call <em>probability amplitudes</em>, are complex valued.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="superposition-revisited">
<h1><span class="section-number">31. </span>Superposition revisited<a class="headerlink" href="#superposition-revisited" title="Permalink to this headline"></a></h1>
<p>And a superposition is just the expansion of this vector in a basis. For instance, if it expanded in the canonical basis, like this, then we can introduce a notation for the <span class="math notranslate nohighlight">\(1 0\)</span> vector and the <span class="math notranslate nohighlight">\(0 1\)</span> vector.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]=a_{0}\left[\begin{array}{c}1\\0\end{array}\right]+a_{1}\left[\begin{array}{c}0\\1\end{array}\right]=a_{0}\mid0\rangle+a_{1}\mid1\rangle\end{split}\]</div>
<p>Outcome <span class="math notranslate nohighlight">\(0\)</span> with probability
$<span class="math notranslate nohighlight">\(\mid a_{0}\mid^{2}\)</span>$</p>
<p>state afterwards:
$<span class="math notranslate nohighlight">\(\mid0\rangle\)</span>$</p>
<p>Now the</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{array}{c}1\\0\end{array}\right]\end{split}\]</div>
<p>is called the 0 ket
$<span class="math notranslate nohighlight">\(\mid0\rangle\)</span>$</p>
<p>And the
$<span class="math notranslate nohighlight">\(\left[\begin{array}{c}0\\1\end{array}\right]\)</span>$</p>
<p>the second basis vector, is called the 1 ket</p>
<div class="math notranslate nohighlight">
\[\mid1\rangle\]</div>
<p>And this notation, the vertical bar, and this little angle, often the name of the vector– is ket. This gives us the same idea as in a stochastic vector, that we have to put an arrow on top of the vector, that will help us in the syntax of writing calculations on the quantum states. Here</p>
<div class="math notranslate nohighlight">
\[a_{0}\mid0\rangle+a_{1}\mid1\rangle\]</div>
<p>is the superposition of the <span class="math notranslate nohighlight">\(0\)</span> and the <span class="math notranslate nohighlight">\(1 ket\)</span> , with different coefficients <span class="math notranslate nohighlight">\(a_{0}\)</span> and <span class="math notranslate nohighlight">\(a_{1}\)</span>. So these coefficients are called probability amplitudes. They no longer represent probabilities directly, as in the case of a stochastic vector, but it’s the absolute value squared of these values what gives you a probability. So, for instance, you get the outcome 0, with probability a0 squared and, similarly, outcome 1, with probability of the absolute value of a1 squared. And, once you get an outcome 0,</p>
<div class="math notranslate nohighlight">
\[a_{0}\mid0\rangle+a_{1}\mid1\rangle\]</div>
<p>you know that the state is in the 0 state. And similarly, if you get the outcome 1, afterwards the state is going to be in the state 1. This is called the “collapse of the wave function.” A quantum state is also called a wave function. And basically, once you pull out a sample of this distribution and you get an outcome, you make that observation, then you get the deterministic state afterwards, after the random outcome. So you can also think about it in a more geometric way. So now you have a two-dimensional complex space which would take a four dimensions to visualize. But we have this restriction on the degree of freedom. So we can have some three-dimensional object representing these qubit states.</p>
<p>Let us introduce two special qubits, corresponding to the canonical basis vectors in two dimensions:
$<span class="math notranslate nohighlight">\(\mid 0\rangle\)</span><span class="math notranslate nohighlight">\( 
and 
\)</span><span class="math notranslate nohighlight">\(\mid 1\rangle\)</span>$</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid 0\rangle = \begin{bmatrix} 1 \\ 0 \\ \end{bmatrix}, \,\,\, \mid 1\rangle = \begin{bmatrix} 0 \\ 1 \\ \end{bmatrix}\end{split}\]</div>
<p>This basis is also called the computational basis in quantum computing.</p>
<p>We can expand an arbitrary qubit state in this basis:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid \psi\rangle = \begin{bmatrix}a_0 \\ a_1 \\ \end{bmatrix}=a_0\begin{bmatrix}1 \\0 \\\end{bmatrix} + a_1\begin{bmatrix} 0 \\ 1 \\ \end{bmatrix}= a_0 \mid 0\rangle+a_1 \mid 1\rangle\end{split}\]</div>
<p>This expansion in a basis is called a superposition. If we sample the qubit state, we obtain the outcome 0 with probability <span class="math notranslate nohighlight">\(|a_0|^2\)</span>, and 1 with probability <span class="math notranslate nohighlight">\(|a_1|^2\)</span>. This is known as the Born rule; you will learn more about measurements and this rule in a subsequent notebook.</p>
<p>For now, let’s take a look at how we can simulate classical coin tossing on a quantum computer. Let’s start with a completely biased case where we get heads with probability 1. This means that our qubit <span class="math notranslate nohighlight">\(|\psi\rangle=|0\rangle\)</span>. We create a circuit of a single qubit and a single classical register where the results of the sampling (measurements) go.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">QuantumRegister</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">execute</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">BasicAer</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span><span class="p">,</span> <span class="n">plot_bloch_multivector</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">π</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

<span class="n">backend</span> <span class="o">=</span> <span class="n">BasicAer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;qasm_simulator&#39;</span><span class="p">)</span>

<span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Any qubit is initialized in <span class="math notranslate nohighlight">\(|0\rangle\)</span>, so if we measure it right away, we should get our maximally biased coin.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;qiskit.circuit.instructionset.InstructionSet at 0x10f511390&gt;
</pre></div>
</div>
</div>
</div>
<p>Let us execute it a hundred times and study the result</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{&#39;0&#39;: 100}
</pre></div>
</div>
</div>
</div>
<p>As expected, all of our outcomes are 0.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="bloch-sphere-revisited">
<h1><span class="section-number">32. </span>Bloch Sphere revisited<a class="headerlink" href="#bloch-sphere-revisited" title="Permalink to this headline"></a></h1>
<p>So this is where the Bloch sphere helps us. So Bloch sphere is this three-dimensional sphere, but with a slightly different geometry than a normal sphere. So here the north pole is identified with the 0 ket, and the south pole is identified with the 1 ket.</p>
<p>It’s a little bit unusual, because these two basis vectors are actually orthogonal. And it gives an illusion as if they’re relying on the same line. So just keep in mind that orthogonality is a little bit different in this sphere. And now every single point on the surface of the sphere is a qubit state</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]\qquad}a\in\mathbb{C}\end{split}\]</div>
<p>So, basically, you have a much larger representative power. If you compare it, for instance, with classical probability distributions, where every single probability distribution lies on this straight line, as opposed to this large, two-dimensional surface of the Bloch sphere. Now, there are a couple of things that we can do with quantum states which we cannot do, for instance, in classical digital computers. <br></p>
<p>To understand the possible quantum states, we use the Bloch sphere visualization. Since the probability amplitudes are complex and there are two of them for a single qubit, this would require a four-dimensional space. Now since the vectors are normalized, this removes a degree of freedom, allowing a three-dimensional representation with an appropriate embedding. This embedding is the Bloch sphere. It is slightly different than an ordinary sphere in three dimensions: we identify the north pole with the state
$<span class="math notranslate nohighlight">\(\mid 0\rangle\)</span><span class="math notranslate nohighlight">\( 
and the south pole with \)</span>|1\rangle$. In other words, two orthogonal vectors appear as if they were on the same axis – the axis Z. The computational basis is just one basis: the axes X and Y represent two other bases. Any point on the surface of this sphere is a valid quantum state. This is also true the other way around: every pure quantum state is a point on the Bloch sphere. Here it ‘pure’ is an important technical term and it essentially means that the state is described by a ket (column vector). Later in the course we will see other states called mix states that are not described by a ket (you will see later that these are inside the Bloch sphere).</p>
<p>To make it less abstract, let’s plot our
$<span class="math notranslate nohighlight">\(\mid 0\rangle\)</span>$
on the Bloch sphere:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backend_statevector</span> <span class="o">=</span> <span class="n">BasicAer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">&#39;statevector_simulator&#39;</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="c1">#circuit.iden(q[0])</span>
<span class="c1">#QuantumCircuit.iden(q[0])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend_statevector</span><span class="p">)</span>
<span class="n">plot_bloch_multivector</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/34da282e5c7ce041060e209d91c05150d0eab09c93848a75db7f726ebb5087be.png" src="../../_images/34da282e5c7ce041060e209d91c05150d0eab09c93848a75db7f726ebb5087be.png" />
</div>
</div>
<p>Compare this sphere with the straight line in the positive orthant that describes all classical probability distributions of coin tosses. You can already see that there is a much richer structure in the quantum probability space.</p>
<p>Let us pick another point on the Bloch sphere, that is, another distribution. Let’s transform the state
$<span class="math notranslate nohighlight">\(\mid 0\rangle\)</span><span class="math notranslate nohighlight">\( 
to 
\)</span><span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)\)</span><span class="math notranslate nohighlight">\( 
This corresponds to the unbiased coin, since we will get 0 with probability 
\)</span><span class="math notranslate nohighlight">\(\mid\frac{1}{\sqrt{2}}|^2=1/2\)</span><span class="math notranslate nohighlight">\( 
and the other way around. There are many ways to do this transformation. We pick a rotation around the Y axis by \)</span>\pi/2<span class="math notranslate nohighlight">\(, which corresponds to the matrix 
\)</span><span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; -1\\1 &amp; 1\end{bmatrix}\)</span>$</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/aca988e296a3559e4d15666e69088ec8c24d2a68e146b066f7f0e03a6ee65f35.png" src="../../_images/aca988e296a3559e4d15666e69088ec8c24d2a68e146b066f7f0e03a6ee65f35.png" />
</div>
</div>
<p>To get an intuition why it is called a rotation around the Y axis, let’s plot it on the Bloch sphere:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend_statevector</span><span class="p">)</span>
<span class="n">plot_bloch_multivector</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/7d07ea3a57fbe73167f27f412b2c4676b7c242e7309a59abc7220dfe7d5bee6c.png" src="../../_images/7d07ea3a57fbe73167f27f412b2c4676b7c242e7309a59abc7220dfe7d5bee6c.png" />
</div>
</div>
<p>It does exactly what it says: it rotates from the north pole of the Bloch sphere.</p>
<p>Why is interesting to have complex probability amplitudes instead of non-negative real numbers? To get some insight, take a look what happens if we apply the same rotation to <span class="math notranslate nohighlight">\(|1\rangle\)</span>. To achieve this, first we flip <span class="math notranslate nohighlight">\(|0\rangle\)</span> to <span class="math notranslate nohighlight">\(|1\rangle\)</span> by applying a NOT gate (denoted by X in quantum computing) and then the rotation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend_statevector</span><span class="p">)</span>
<span class="n">plot_bloch_multivector</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/055ff131c382ea1ed8ddefed674753e8799bb1907585f14a695136793f1c8b80.png" src="../../_images/055ff131c382ea1ed8ddefed674753e8799bb1907585f14a695136793f1c8b80.png" />
</div>
</div>
<p>We can verify that the result is
$<span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(-|0\rangle + |1\rangle)\)</span>$
That is, the exact same state as before, except that the first term got a minus sign: it is a negative probability amplitude. Note that the difference cannot be observed from the statistics:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/86144182a1afcde982fa6c7a27347c20165e38bb141c4e5219766d1c80b72683.png" src="../../_images/86144182a1afcde982fa6c7a27347c20165e38bb141c4e5219766d1c80b72683.png" />
</div>
</div>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="interference">
<h1><span class="section-number">33. </span>Interference<a class="headerlink" href="#interference" title="Permalink to this headline"></a></h1>
<p>Interference is a strange phenomenon where the different basis vectors and the coefficients interact in your calculations.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{1}{\sqrt{2}}\left[\begin{array}{cc}1 &amp; -1\\1 &amp; 1\end{array}\right]\mid0\rangle=\frac{1}{\sqrt{2}}\left[\begin{array}{cc}1 &amp; -1\\1 &amp; 1\end{array}\right]\left[\begin{array}{c} 1\\1\end{array}\right]=\frac{1}{\sqrt{2}}(\mid0\rangle+\mid1\rangle)\end{split}\]</div>
<p>So imagine that you act on your 0 ket with this particular matrix. Remember that, in your transform stochastic vectors, with matrices, with stochastic matrices, to ensure that the result is also a stochastic vector, a probability distribution, quantum states are also acted on by these operators, and they fulfill certain conditions that we will learn later. Now, just accept that this is a valid operation, and it transform the 0 ket into the equal superposition of the 0 and the 1 ket. And, if you are acting on the 1 ket, the only difference would be that it would introduce a negative sign to the 0 ket.</p>
<div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{2}}(-\mid0\rangle+\mid1\rangle\]</div>
<p>Interestingly is, if we now take this outcome
$<span class="math notranslate nohighlight">\(\frac{1}{\sqrt{2}}(\mid0\rangle+\mid1\rangle)\)</span>$
and we apply the same operation on it– that’s what we are doing here– so I take this outcome, and I apply the same operation on it– then something interesting is happening. So this is a linear operator, so I can pull out the 1 over square root 2 the front, so it simplifies to 1/2. And I can also take the matrix operation basis vector by basis vector in the superposition.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{1}{\sqrt{2}}\left[\begin{array}{cc}1 &amp; -1\\1 &amp; 1\end{array}\right]\frac{1}{\sqrt{2}}(\mid0\rangle+\mid1\rangle)=\frac{1}{2}\left(\mid0\rangle+\mid1\rangle-\mid0\rangle+\mid1\rangle\right)\end{split}\]</div>
<p>So I act on the first one. From that, I get the superposition of 0 and 1 <span class="math notranslate nohighlight">\(\mid0\rangle+\mid1\rangle\)</span>, just like here, the same thing. And then I have the 1 ket, so I’m going to get this outcome, which we calculated here. And now, if you look at this, these two cancel out</p>
<div class="math notranslate nohighlight">
\[\require{cancel}\]</div>
<div class="math notranslate nohighlight">
\[\frac{1}{2}\left(\cancel{\mid0\rangle}+\mid1\rangle-\cancel{\mid0\rangle}+\mid1\rangle\right)\]</div>
<p>Which means that we get a deterministic outcome by applying the operator again. So this is an example of interference. So t he probability amplitudes of the 0 ket destructive interfere, they vanish from the superposition, and you get the deterministic 1 outcome.</p>
<section id="quiz-quantum-states">
<h2><span class="section-number">33.1. </span>Quiz Quantum States<a class="headerlink" href="#quiz-quantum-states" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Is
$<span class="math notranslate nohighlight">\(\frac{1}{3}\mid0\rangle+\sqrt{\frac{2}{3}}\mid1\rangle\)</span>$
a valid quantum state?</p></li>
</ul>
<p><strong>False</strong></p>
<ul class="simple">
<li><p>In a quantum state, the probability amplitudes are not restricted to the positive orthant. This is what enables interference.</p></li>
</ul>
<p><strong>True</strong></p>
<ul class="simple">
<li><p>The points on the surface of the Bloch sphere…</p></li>
</ul>
<p><strong>are qubit states</strong></p>
<p>It still looks like an approximately unbiased coin. Yet, that negative sign – or any complex value – is what models <em>interference</em>, a critically important phenomenon where probability amplitudes can interact in a constructive or a destructive way. To see this, if we apply the rotation twice in a row on
$<span class="math notranslate nohighlight">\(|0\rangle\)</span><span class="math notranslate nohighlight">\( 
we get another deterministic output, 
\)</span><span class="math notranslate nohighlight">\(1\rangle\)</span>$
although in between the two, it was some superposition.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">π</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/d20567d853f2cdeba09477e546dae46b177d0ea20645be32af9e539b973d6212.png" src="../../_images/d20567d853f2cdeba09477e546dae46b177d0ea20645be32af9e539b973d6212.png" />
</div>
</div>
<p>Many quantum algorithms exploit interference, for instance, the seminal <a class="reference external" href="https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm">Deutsch-Josza algorithm</a>, which is among the simplest to understand its significance.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="more-qubits-and-entanglement">
<h1><span class="section-number">34. </span>More qubits and entanglement<a class="headerlink" href="#more-qubits-and-entanglement" title="Permalink to this headline"></a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="multiple-qubits-revisited">
<h1><span class="section-number">35. </span>Multiple Qubits revisited<a class="headerlink" href="#multiple-qubits-revisited" title="Permalink to this headline"></a></h1>
<p>Starting with the simplest possible quantum system, a qubit state and try to construct larger probability distributions, or larger states, which are composed of several qubits. Before we go there, we have to introduce a new mathematical operation, a tensor product. Imagine that you have two quantum states, two kets. One has a probability amplitudes a0 a1, and the second one has b0 and b1.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid\psi\rangle=\left[\begin{array}{c}a_{0}\\a_{1}\end{array}\right]\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mid\psi'\rangle=\left[\begin{array}{c}b_{0}\\b_{1}\end{array}\right]\end{split}\]</div>
<p>Now, then, we can define this tensor product as this object.</p>
<div class="math notranslate nohighlight">
\[\begin{split}|\psi\rangle\otimes|\psi\prime\rangle=\left[\begin{array}{c}a_{0}b_{0}\\a_{0}b_{1}\\a_{1}b_{0}\\a_{1}b_{1}\end{array}\right]\end{split}\]</div>
<p>First we have
$<span class="math notranslate nohighlight">\(a_{0} \otimes b_{0}\)</span><span class="math notranslate nohighlight">\(
as the first component, and you have 
\)</span><span class="math notranslate nohighlight">\(a_{0} \otimes b_{1}\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(a_{1} \otimes b_{0}\)</span><span class="math notranslate nohighlight">\(
which is a four-dimensional complex vector. These are independently two-dimensional complex vectors, and here we create a four-dimensional one. And now we can also look at this probability distribution-- has four possible outcomes. We can create a basis, in this space by taking our \)</span>0<span class="math notranslate nohighlight">\( ket and take the tensor product of the other \)</span>0$ kets.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid0\rangle\otimes\mid0\rangle=\mid0\rangle\mid0\rangle=\mid00\rangle=\left[\begin{array}{c}1\\0\\0\\0\end{array}\right]\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mid0\rangle\otimes\mid1\rangle=\mid0\rangle\mid1\rangle=\mid01\rangle=\left[\begin{array}{c}0\\1\\0\\0\end{array}\right]\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mid1\rangle\otimes\mid0\rangle=\mid1\rangle\mid0\rangle=\mid11\rangle=\left[\begin{array}{c}0\\0\\1\\0\end{array}\right]\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mid1\rangle\otimes\mid1\rangle=\mid1\rangle\mid1\rangle=\mid11\rangle=\left[\begin{array}{c}0\\0\\0\\1\end{array}\right]\end{split}\]</div>
<p>Convention right most qubit is qubit <span class="math notranslate nohighlight">\(0\)</span></p>
<p>The shorthand notation for this is just dropping the tensor product sign. Even shorter notation is by dropping the two kets, here, and just contracting them into one. And if we calculate the product, then we end up with the first canonical basis vector of the four-dimensional space. The same thing with 0 and 1, 1 0, and 1 1. Noticing that these are the four possibilities, the four canonical basis vectors, in the four-dimensional complex space. There’s a very important convention that most quantum-computing libraries out there use, which is that it’s the rightmost qubit which is the qubit 0. This would be qubit 0. And then to the left of it would be qubit 1, and so on, and so forth.<br>
This is the same order of representing binary values as you would have in most digital computers, and that’s why this convention is maintained in these quantum-computing frameworks. These are called “product states,” but there are also states which cannot be written in this form, even though they live in the same space. One example is the <span class="math notranslate nohighlight">\(\phi+\)</span> state.</p>
<div class="math notranslate nohighlight">
\[\mid\psi\rangle\otimes|\psi\prime\rangle\in C^{2}\otimes C^{2}\]</div>
<p>It’s written as an equal superposition of two basis vectors, 0 0 and 1 1, so it’s definitely in the same space as our product vector.</p>
<div class="math notranslate nohighlight">
\[\phi^{\dagger'}=\frac{1}{\sqrt{2}}(\mid00\rangle+\mid11\rangle)\in C^{2}\otimes C^{2}\]</div>
<p>But it cannot be written as a product vector. And, to see that, let’s take a look at the general structure of this product vector.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mid\psi\rangle\otimes|\psi\prime\rangle=\left[\begin{array}{c}a_{0}b_{0}\\a_{0}b_{1}\\a_{1}b_{0}\\a_{1}b_{1}\end{array}\right]=a_{0}b_{0}\mid00\rangle+a_{0}b_{10}\mid01\rangle+a_{1}b_{0}\mid10\rangle+a_{1}b_{1}\mid11\rangle\end{split}\]</div>
<p>We copied the definition of the product vector here and wrote it down in the canonical basis. It would have a0 times b0 times the 0 0 ket, and so on. It has four components. And let us assume that there is some combination of these ai and bj values such that we can write this phi plus state as a product state.</p>
<div class="math notranslate nohighlight">
\[\phi^{\dagger'} = \mid\psi\rangle\otimes\mid\psi\prime\rangle\]</div>
<p>So this means that, either here we have 0 0 ket with a coefficient 1 over square root 2– so this equation must be fulfilled.</p>
<div class="math notranslate nohighlight">
\[a_{0}b_{0}=\frac{1}{\sqrt{2}}\qquad a_{0}b_{1}=0\]</div>
<div class="math notranslate nohighlight">
\[\underbrace{a_{0}b_{0}=\frac{1}{\sqrt{2}}}_{\text{Entangled state}}\qquad a_{1}b_{0}=0\]</div>
<p>Similarly, we have the <span class="math notranslate nohighlight">\(1 1\)</span> ket with the same coefficient. This condition must be fulfilled. And we also see that there is no 0 1 and 1 0, so the corresponding coefficient must be 0. But now, it means that either a0 or b1 must be 0. a0 cannot be 0, because it multiplies to some known nonzero value, but the same is true for b1. Therefore the state, although it lives in the same space, cannot be written as a product state. Such states are called “entangled states,” and they play a very important role in quantum computing, together with interference. So these are the main quantum-mechanical properties that we exploit in quantum calculations, as you will see in subsequent lectures.</p>
<section id="quiz">
<h2><span class="section-number">35.1. </span>Quiz<a class="headerlink" href="#quiz" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>The <span class="math notranslate nohighlight">\(\mid00\rangle\)</span> state is the same as…
$<span class="math notranslate nohighlight">\(\mid0\rangle\otimes\mid0\rangle\)</span>$</p></li>
</ul>
<p>– the first basis vector in the canonical basis in four dimensions.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{array}{c}1 \\0\\0\\0\end{array}\right]\end{split}\]</div>
<p>Since the basis of
$<span class="math notranslate nohighlight">\(\mathbb{C}^{2}\otimes\mathbb{C}^{2}\)</span>$
is created as product states, all states in this space must be product states.</p>
<p><strong>False</strong></p>
<p>We have already seen that quantum states are probability distributions normed to <span class="math notranslate nohighlight">\(1\)</span> in the <span class="math notranslate nohighlight">\(l_{2}\)</span> norm and we got a first peek at interference. If we introduce more qubits, we see another crucial quantum effect emerging. To do that, we first have to define how we write down the column vector for describing two qubits. Using a tensor product, which, in the case of qubits, is equivalent to the Kronecker product. Given two qubits,
$<span class="math notranslate nohighlight">\(\mid\psi\rangle=\begin{bmatrix}a_0\\a_1\end{bmatrix}\)</span><span class="math notranslate nohighlight">\( 
and 
\)</span><span class="math notranslate nohighlight">\(\mid\psi'\rangle=\begin{bmatrix}b_0\\b_1\end{bmatrix}\)</span><span class="math notranslate nohighlight">\( 
their product is 
\)</span><span class="math notranslate nohighlight">\(\mid\psi\rangle\otimes\mid\psi'\rangle = \begin{bmatrix}a_0b_0\\ a_0b_1\\ a_1b_0\\ a_1b_1\end{bmatrix}\)</span><span class="math notranslate nohighlight">\( 
Imagine that you have two registers 
\)</span>q_{0}<span class="math notranslate nohighlight">\( and \)</span>q_{1}<span class="math notranslate nohighlight">\( 
each can hold a qubit, and both qubits are in the state 
\)</span><span class="math notranslate nohighlight">\(\mid 0\rangle\)</span>$
Then this composite state would be described by according to this product rule as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">q0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">q1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1],
       [0],
       [0],
       [0]])
</pre></div>
</div>
</div>
</div>
<p>This is the <span class="math notranslate nohighlight">\(|0\rangle\otimes|0\rangle\)</span> state, which we often abbreviate as <span class="math notranslate nohighlight">\(|00\rangle\)</span>. The states <span class="math notranslate nohighlight">\(|01\rangle\)</span>, <span class="math notranslate nohighlight">\(|10\rangle\)</span>, and <span class="math notranslate nohighlight">\(|11\rangle\)</span> are defined analogously, and the four of them give the canonical basis of the four dimensional complex space, <span class="math notranslate nohighlight">\(\mathbb{C}^2\otimes\mathbb{C}^2\)</span>.</p>
<p>Now comes the interesting and counter-intuitive part. In machine learning, we also work with high-dimensional spaces, but we never construct it as a tensor product: it is typically <span class="math notranslate nohighlight">\(\mathbb{R}^d\)</span> for some dimension <span class="math notranslate nohighlight">\(d\)</span>. The interesting part of writing the high-dimensional space as a tensor product is that not all vectors in can be written as a product of vectors in the component space.</p>
<p>Take the following state: <span class="math notranslate nohighlight">\(|\phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle)\)</span>. This vector is clearly in <span class="math notranslate nohighlight">\(\mathbb{C}^2\otimes\mathbb{C}^2\)</span>, since it is a linear combination of two of the basis vector in this space. Yet, it cannot be written as <span class="math notranslate nohighlight">\(|\psi\rangle\otimes|\psi'\rangle\)</span> for some <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, <span class="math notranslate nohighlight">\(|\psi'\rangle\in\mathbb{C}^2\)</span>.</p>
<p>To see this, assume that it can be written in this form. Then</p>
<div class="math notranslate nohighlight">
\[\begin{split}
|\phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle+|11\rangle) = \begin{bmatrix}a_0b_0\\ a_0b_1\\ a_1b_0\\ a_1b_1\end{bmatrix} = a_0b_0|00\rangle + a_0b_1|01\rangle + a_1b_0|10\rangle + a_1b_1|11\rangle.
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(|01\rangle\)</span> and <span class="math notranslate nohighlight">\(|10\rangle\)</span> do not appear on the left-hand side, so their coefficients must be zero: <span class="math notranslate nohighlight">\(a_1b_0=0\)</span> and <span class="math notranslate nohighlight">\(a_0b_1=0\)</span>. This leads to a contradiction, since <span class="math notranslate nohighlight">\(a_1\)</span> cannot be zero (<span class="math notranslate nohighlight">\(a_1b_1=1\)</span>), so <span class="math notranslate nohighlight">\(b_0\)</span> must be zero, but <span class="math notranslate nohighlight">\(a_0b_0=1\)</span>. Therefore <span class="math notranslate nohighlight">\(|\phi^+\rangle\)</span> cannot be written as a product.</p>
<p>States that cannot be written as a product are called entangled states. This is the mathematical form of describing a phenomenon of strong correlations between random variables that exceed what is possible classically. Entanglement plays a central role in countless quantum algorithms. A simple example is <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_teleportation">quantum teleportation</a>. We will also see its applications in quantum machine learning protocols.</p>
<p>We will have a closer look at entanglement in a subsequent notebook on measurements, but as a teaser, let us look at the measurement statistics of the <span class="math notranslate nohighlight">\(|\phi^+\rangle\)</span> state. The explanation of the circuit preparing it will also come in a subsequent notebook.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">QuantumRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="n">job</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">circuit</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/ff590da60f36d6fad0a21a3f7eb04b9a02daa1db1555fd000bc899037dd97702.png" src="../../_images/ff590da60f36d6fad0a21a3f7eb04b9a02daa1db1555fd000bc899037dd97702.png" />
</div>
</div>
<p>Notice that 01 or 10 never appear in the measurement statistics.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="further-reading">
<h1><span class="section-number">36. </span>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline"></a></h1>
<p>Chapter 9 in Quantum Computing since Democritus by Scott Aaronson describes a similar approach to understanding quantum states – in fact, the interference example was lifted from there.</p>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./quantum_machine_learning/qml"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="qml_0.html" class="btn btn-neutral float-left" title="23.1. Quantum Machine Learning 0" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="1_2_QML_Quantum_Systems__Measurements_And_Mixed_States_qiskit_QDaria.html" class="btn btn-neutral float-right" title="37. Measurements revisited" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>